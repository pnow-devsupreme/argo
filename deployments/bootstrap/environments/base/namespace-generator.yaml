# File: deployments/bootstrap/environments/base/namespace-generator.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: namespace-manager
  namespace: argocd
spec:
  template:
    spec:
      containers:
        - name: kubectl
          image: bitnami/kubectl:latest
          command:
            - /bin/sh
            - -c
            - |
              # First, create our domain configuration
              cat > /tmp/domain-config.yaml << 'EOL'
              domains:
                platform:
                  level: 0
                  description: "Platform level components"
                infrastructure:
                  level: 1
                  description: "Infrastructure components"
                workloads:
                  level: 2
                  description: "Workload components"
                applications:
                  level: 2
                  description: "Business applications"
              EOL
              # Function to validate namespace configuration
              validate_namespace() {
                local domain=$1
                local env=$2
                echo "Validating namespace ${domain}-${env}..."
                # Check if all required resources exist
                local resources=("networkpolicy" "resourcequota" "limitrange" "serviceaccount")
                for resource in "${resources[@]}"; do
                  if ! kubectl get ${resource} -n ${domain}-${env} &>/dev/null; then
                    echo "Error: ${resource} not found in namespace ${domain}-${env}"
                    return 1
                  fi
                done
                # Verify labels are correct
                local namespace_labels=$(kubectl get namespace ${domain}-${env} -o jsonpath='{.metadata.labels}')
                if ! echo "$namespace_labels" | grep -q "access-level"; then
                  echo "Error: access-level label missing in namespace ${domain}-${env}"
                  return 1
                fi
                echo "âœ“ Namespace ${domain}-${env} validation successful"
                return 0
              }
              # Function to process individual templates from ConfigMap
              process_template() {
                local domain=$1
                local env=$2
                local level=$3
                local template_type=$4
                echo "Processing ${template_type} for ${domain}-${env} with access level ${level}"
                # Read template from ConfigMap
                local template=$(kubectl get configmap namespace-templates -n argocd -o jsonpath="{.data.${template_type}}")
                # Replace variables and apply
                echo "$template" | sed \
                    -e "s/\${domain}/$domain/g" \
                    -e "s/\${env}/$env/g" \
                    -e "s/\${level}/$level/g" | kubectl apply -f -
              }
              # Main function to create namespace and its resources
              create_namespace() {
                local domain=$1
                local env=$2
                local level=$3
                echo "Creating namespace ${domain}-${env} with access level ${level}"
                # Create the namespace with labels
                cat << EOF | kubectl apply -f -
                apiVersion: v1
                kind: Namespace
                metadata:
                  name: ${domain}-${env}
                  labels:
                    domain: ${domain}
                    environment: ${env}
                    access-level: ${level}
                    managed-by: "argocd"
                EOF
                # Process each required template
                process_template "$domain" "$env" "$level" "network-policy"
                process_template "$domain" "$env" "$level" "resource-quota"
                process_template "$domain" "$env" "$level" "limit-range"
                process_template "$domain" "$env" "$level" "service-account"
                # Verify the namespace was created with correct labels
                echo "Verifying namespace ${domain}-${env}"
                kubectl get namespace ${domain}-${env} --show-labels
              }
              # Main execution loop
              echo "Starting namespace creation process..."
              while read -r domain level; do
                for env in staging production; do
                  create_namespace "$domain" "$env" $level
                done
              done < <(yq eval '.domains | to_entries | .[] | .key + " " + .value.level' /tmp/domain-config.yaml)
              # Wait for all namespaces to be fully active
              echo "Waiting for namespaces to be ready..."
              for domain in platform infrastructure workloads applications; do
                for env in staging production; do
                  echo "Waiting for ${domain}-${env} namespace to be ready..."
                  if ! kubectl wait --for=condition=Active namespace/${domain}-${env} --timeout=60s; then
                    echo "Error: Timeout waiting for namespace ${domain}-${env}"
                    exit 1
                  fi
                done
              done
              # Perform validation after all namespaces are ready
              echo "Starting namespace validation..."
              failed=0
              for domain in platform infrastructure workloads applications; do
                for env in staging production; do
                  if ! validate_namespace "$domain" "$env"; then
                    failed=1
                  fi
                done
              done
              # Exit with error if any validation failed
              if [ $failed -eq 1 ]; then
                echo "One or more namespace validations failed"
                exit 1
              fi
              echo "All namespaces created and validated successfully"
          volumeMounts:
            - name: templates
              mountPath: /templates
              # We don't need the domain-config volume anymore as we create it inline
      serviceAccountName: namespace-creator
